В диапазоне натуральных чисел от 2 до 99 определить,
# сколько из них кратны каждому из чисел в диапазоне от 2 до 9

#разницы по времени их реализации несущественны.
#1 вариант кода


import timeit
a = [0]*8
for i in range(2,100):
     for j in range(2,10):
         if i % j == 0:
             a[j-2] += 1

for i, item in enumerate(a, start=2):
     # print(timeit.timeit(f'{i},{item}'))
    print(f'{i},{item}')



# через терминал:
# 1000 loops, best of 5: 49.7 nsec per loop

# через код:
#0.0518807
# 0.051801899999999984
# 0.04812230000000001
# 0.047955899999999996
# 0.0486239
# 0.05279909999999999
# 0.04885609999999996
# 0.048227200000000026

#2 вариант кода:


import numpy as np
b = np.arange(2, 10, 1)

for j in b:
    a = [i for i in range(2, 100) if i % j == 0]
    print(f'числу {j}  кратно {len(a)}  чисел')


#через терминал:
#1000 loops, best of 5: 49.5 nsec per loop


#через код:
#0.0479286000000001
# 0.047321500000000016
# 0.04733390000000015
# 0.04786670000000015
# 0.047338800000000125
# 0.07830669999999995
# 0.054584500000000036
# 0.051393400000000034


#3 вариант кода

# import cProfile

arr_result = [0] * 8
def get_res():

    for i in range(2, 100):
        for j in range(2, 10):
            if i % j == 0:
                arr_result[j-2] +=1
                # return
    for i, item in enumerate(arr_result, start=2):
        print(f'{i}, {item}')

get_res()


#проверка timeit через терминал
# 1000 loops, best of 5: 49.8 nsec per loop

# проверка через cProfile:
# cProfile.run('get_res()')

#4 function calls in 0.000 seconds

   # Ordered by: standard name
   #
   # ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   #      1    0.000    0.000    0.000    0.000 4.1.py:53(get_res)
   #      1    0.000    0.000    0.000    0.000 <string>:1(<module>)
   #      1    0.000    0.000    0.000    0.000 {built-in method builtins.exec}
   #      1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}